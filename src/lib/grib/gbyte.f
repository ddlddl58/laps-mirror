      SUBROUTINE GBYTE(IN,IOUT,ISKIP,NBYTE)
C     
C THIS PROGRAM WRITTEN BY.....
C             DR. ROBERT C. GAMMILL, CONSULTANT
C             NATIONAL CENTER FOR ATMOSPHERIC RESEARCH
C             MAY 1972
C THIS IS THE FORTRAN VERSION OF GBYTE.
C     
C             CHANGES FOR FORTRAN 90
C             AUGUST 1990  RUSSELL E. JONES
C             NATIONAL WEATHER SERVICE
C             GBYTE RUN WITHOUT CHANGES ON THE FOLLOWING COMPILERS
C             MICROSOFT FORTRAN 5.0 OPTIMIZING COMPILER
C             SVS 32 386 FORTRAN 77 VERSION V2.8.1B
C             SUN FORTRAN 1.3, 1.4
C             DEC VAX FORTRAN
C             SILICONGRAPHICS 3.3, 3.4 FORTRAN 77
C             IBM370 VS COMPILER
C             INTERGRAPH GREEN HILLS FORTRAN CLIPPER 1.8.4B
C     
C USAGE:    CALL GBYTE (PCKD,UNPK,INOFST,NBIT)
C   INPUT ARGUMENT LIST:
C    PCKD      -  THE FULLWORD IN MEMORY FROM WHICH UNPACKING IS TO
C                 BEGIN; SUCCESSIVE FULLWORDS WILL BE FETCHED AS
C                 REQUIRED.
C    INOFST    -  A FULLWORD INTEGER SPECIFYING THE INITAL OFFSET
C                 IN BITS OF THE FIRST BYTE, COUNTED FROM THE
C                 LEFTMOST BIT IN PCKD.
C    NBITS     -  A FULLWORD INTEGER SPECIFYING THE NUMBER OF BITS
C                 IN EACH BYTE TO BE UNPACKED.  LEGAL BYTE WIDTHS
C                 ARE IN THE RANGE 1 - 32; BYTES OF WIDTH .LT. 32
C                 WILL BE RIGHT JUSTIFIED IN THE LOW-ORDER POSITIONS
C                 OF THE UNPK FULLWORDS, WITH HIGH-ORDER ZERO FILL.
C     
C   OUTPUT ARGUMENT LIST:
C     UNPK:    -  THE FULLWORD IN MEMORY INTO WHICH THE INITIAL BYTE
C                 OF UNPACKED DATA IS TO BE STORED.
C     
      INTEGER    IN(*)
      INTEGER    IOUT
      INTEGER    MASKS(32)
C     
      DATA  NBITSW/32/
C     
C      DATA  MASKS /Z'00000001',Z'00000003',Z'00000007',Z'0000000F',
C     &             Z'0000001F',Z'0000003F',Z'0000007F',Z'000000FF',
C     &             Z'000001FF',Z'000003FF',Z'000007FF',Z'00000FFF',
C     &             Z'00001FFF',Z'00003FFF',Z'00007FFF',Z'0000FFFF',
C     &             Z'0001FFFF',Z'0003FFFF',Z'0007FFFF',Z'000FFFFF',
C     &             Z'001FFFFF',Z'003FFFFF',Z'007FFFFF',Z'00FFFFFF',
C     &             Z'01FFFFFF',Z'03FFFFFF',Z'07FFFFFF',Z'0FFFFFFF',
C     &             Z'1FFFFFFF',Z'3FFFFFFF',Z'7FFFFFFF',Z'FFFFFFFF'/
C     
C     MASK TABLE PUT IN DECIMAL SO IT WILL COMPILE ON AN 32 BIT
C     COMPUTER
C     
      DATA  MASKS / 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047,
     & 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287,
     & 1048575, 2097151, 4194303, 8388607, 16777215, 33554431,
     & 67108863, 134217727, 268435455, 536870911, 1073741823,
     & 2147483647, -1/
C     
C NBYTE MUST BE LESS THAN OR EQUAL TO NBITSW
C     
      ICON   = NBITSW - NBYTE
      IF (ICON.LT.0) RETURN
      MASK   = MASKS(NBYTE)
C     
C INDEX TELLS HOW MANY WORDS INTO THE ARRAY 'IN' THE NEXT BYTE APPEARS.
C     
      INDEX  = ISKIP / NBITSW
C     
C II TELLS HOW MANY BITS THE BYTE IS FROM THE LEFT SIDE OF THE WORD.
C     
      II     = MOD(ISKIP,NBITSW)
C     
C MOVER SPECIFIES HOW FAR TO THE RIGHT A BYTE MUST BE MOVED IN ORDER
C    TO BE RIGHT ADJUSTED.
C     
      MOVER = ICON - II
C     
C RIGHT ADJUST THE BYTE.
C     
      IF (MOVER.GT.0) THEN
        IOUT = IAND(ISHFT(IN(INDEX+1),-MOVER),MASK)
C     
C THE BYTE IS SPLIT ACROSS A WORD BREAK.
C     
      ELSE IF (MOVER.LT.0) THEN
        MOVEL = - MOVER
        MOVER = NBITSW - MOVEL
        IOUT  = IAND(IOR(ISHFT(IN(INDEX+1),MOVEL),
     &            ISHFT(IN(INDEX+2),-MOVER)),MASK)
C     
C THE BYTE IS ALREADY RIGHT ADJUSTED.
C     
      ELSE
        IOUT = IAND(IN(INDEX+1),MASK)
      ENDIF
C     
        RETURN
      END

